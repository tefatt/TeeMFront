{"ast":null,"code":"var _classCallCheck = require(\"/Users/teufiktutundzic/Desktop/lang-front/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/teufiktutundzic/Desktop/lang-front/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/teufiktutundzic/Desktop/lang-front/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/teufiktutundzic/Desktop/lang-front/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/teufiktutundzic/Desktop/lang-front/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/teufiktutundzic/Desktop/lang-front/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar loadScript = require('load-script2');\n\nvar YOUTUBE_IFRAME_API_SRC = 'https://www.youtube.com/iframe_api';\nvar YOUTUBE_STATES = {\n  '-1': 'unstarted',\n  '0': 'ended',\n  '1': 'playing',\n  '2': 'paused',\n  '3': 'buffering',\n  '5': 'cued'\n};\nvar YOUTUBE_ERROR = {\n  // The request contains an invalid parameter value. For example, this error\n  // occurs if you specify a videoId that does not have 11 characters, or if the\n  // videoId contains invalid characters, such as exclamation points or asterisks.\n  INVALID_PARAM: 2,\n  // The requested content cannot be played in an HTML5 player or another error\n  // related to the HTML5 player has occurred.\n  HTML5_ERROR: 5,\n  // The video requested was not found. This error occurs when a video has been\n  // removed (for any reason) or has been marked as private.\n  NOT_FOUND: 100,\n  // The owner of the requested video does not allow it to be played in embedded\n  // players.\n  UNPLAYABLE_1: 101,\n  // This error is the same as 101. It's just a 101 error in disguise!\n  UNPLAYABLE_2: 150\n};\nvar loadIframeAPICallbacks = [];\n/**\n * YouTube Player. Exposes a better API, with nicer events.\n * @param {HTMLElement|selector} element\n */\n\nvar YouTubePlayer =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(YouTubePlayer, _EventEmitter);\n\n  function YouTubePlayer(element, opts) {\n    var _this;\n\n    _classCallCheck(this, YouTubePlayer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(YouTubePlayer).call(this));\n    var elem = typeof element === 'string' ? document.querySelector(element) : element;\n\n    if (elem.id) {\n      _this._id = elem.id; // use existing element id\n    } else {\n      _this._id = elem.id = 'ytplayer-' + Math.random().toString(16).slice(2, 8);\n    }\n\n    _this._opts = Object.assign({\n      width: 640,\n      height: 360,\n      autoplay: false,\n      captions: undefined,\n      controls: true,\n      keyboard: true,\n      fullscreen: true,\n      annotations: true,\n      modestBranding: false,\n      related: true,\n      info: true,\n      timeupdateFrequency: 1000\n    }, opts);\n    _this.videoId = null;\n    _this.destroyed = false;\n    _this._api = null;\n    _this._autoplay = false; // autoplay the first video?\n\n    _this._player = null;\n    _this._ready = false; // is player ready?\n\n    _this._queue = [];\n    _this._interval = null; // Setup listeners for 'timeupdate' events. The YouTube Player does not fire\n    // 'timeupdate' events, so they are simulated using a setInterval().\n\n    _this._startInterval = _this._startInterval.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._stopInterval = _this._stopInterval.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    _this.on('playing', _this._startInterval);\n\n    _this.on('unstarted', _this._stopInterval);\n\n    _this.on('ended', _this._stopInterval);\n\n    _this.on('paused', _this._stopInterval);\n\n    _this.on('buffering', _this._stopInterval);\n\n    _this._loadIframeAPI(function (err, api) {\n      if (err) return _this._destroy(new Error('YouTube Iframe API failed to load'));\n      _this._api = api; // If load(videoId, [autoplay]) was called before Iframe API loaded, ensure it gets\n      // called again now\n\n      if (_this.videoId) _this.load(_this.videoId, _this._autoplay);\n    });\n\n    return _this;\n  }\n\n  _createClass(YouTubePlayer, [{\n    key: \"load\",\n    value: function load(videoId) {\n      var autoplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.destroyed) return;\n      this.videoId = videoId;\n      this._autoplay = autoplay; // If the Iframe API is not ready yet, do nothing. Once the Iframe API is\n      // ready, `load(this.videoId)` will be called.\n\n      if (!this._api) return; // If there is no player instance, create one.\n\n      if (!this._player) {\n        this._createPlayer(videoId);\n\n        return;\n      } // If the player instance is not ready yet, do nothing. Once the player\n      // instance is ready, `load(this.videoId)` will be called. This ensures that\n      // the last call to `load()` is the one that takes effect.\n\n\n      if (!this._ready) return; // If the player instance is ready, load the given `videoId`.\n\n      if (autoplay) {\n        this._player.loadVideoById(videoId);\n      } else {\n        this._player.cueVideoById(videoId);\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this._ready) this._player.playVideo();else this._queueCommand('play');\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this._ready) this._player.pauseVideo();else this._queueCommand('pause');\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._ready) this._player.stopVideo();else this._queueCommand('stop');\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(seconds) {\n      if (this._ready) this._player.seekTo(seconds, true);else this._queueCommand('seek', seconds);\n    }\n  }, {\n    key: \"setVolume\",\n    value: function setVolume(volume) {\n      if (this._ready) this._player.setVolume(volume);else this._queueCommand('setVolume', volume);\n    }\n  }, {\n    key: \"getVolume\",\n    value: function getVolume() {\n      return this._ready && this._player.getVolume() || 0;\n    }\n  }, {\n    key: \"mute\",\n    value: function mute() {\n      if (this._ready) this._player.mute();else this._queueCommand('mute');\n    }\n  }, {\n    key: \"unMute\",\n    value: function unMute() {\n      if (this._ready) this._player.unMute();else this._queueCommand('unMute');\n    }\n  }, {\n    key: \"isMuted\",\n    value: function isMuted() {\n      return this._ready && this._player.isMuted() || false;\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      if (this._ready) this._player.setSize(width, height);else this._queueCommand('setSize', width, height);\n    }\n  }, {\n    key: \"setPlaybackRate\",\n    value: function setPlaybackRate(rate) {\n      if (this._ready) this._player.setPlaybackRate(rate);else this._queueCommand('setPlaybackRate', rate);\n    }\n  }, {\n    key: \"getPlaybackRate\",\n    value: function getPlaybackRate() {\n      return this._ready && this._player.getPlaybackRate() || 1;\n    }\n  }, {\n    key: \"getAvailablePlaybackRates\",\n    value: function getAvailablePlaybackRates() {\n      return this._ready && this._player.getAvailablePlaybackRates() || [1];\n    }\n  }, {\n    key: \"getDuration\",\n    value: function getDuration() {\n      return this._ready && this._player.getDuration() || 0;\n    }\n  }, {\n    key: \"getProgress\",\n    value: function getProgress() {\n      return this._ready && this._player.getVideoLoadedFraction() || 0;\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this._ready && YOUTUBE_STATES[this._player.getPlayerState()] || 'unstarted';\n    }\n  }, {\n    key: \"getCurrentTime\",\n    value: function getCurrentTime() {\n      return this._ready && this._player.getCurrentTime() || 0;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._destroy();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err) {\n      if (this.destroyed) return;\n      this.destroyed = true;\n\n      if (this._player) {\n        this._player.stopVideo();\n\n        this._player.destroy();\n      }\n\n      this.videoId = null;\n      this._id = null;\n      this._opts = null;\n      this._api = null;\n      this._player = null;\n      this._ready = false;\n      this._queue = null;\n\n      this._stopInterval();\n\n      this.removeListener('playing', this._startInterval);\n      this.removeListener('paused', this._stopInterval);\n      this.removeListener('buffering', this._stopInterval);\n      this.removeListener('unstarted', this._stopInterval);\n      this.removeListener('ended', this._stopInterval);\n      if (err) this.emit('error', err);\n    }\n  }, {\n    key: \"_queueCommand\",\n    value: function _queueCommand(command) {\n      if (this.destroyed) return;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this._queue.push([command, args]);\n    }\n  }, {\n    key: \"_flushQueue\",\n    value: function _flushQueue() {\n      while (this._queue.length) {\n        var command = this._queue.shift();\n\n        this[command[0]].apply(this, command[1]);\n      }\n    }\n  }, {\n    key: \"_loadIframeAPI\",\n    value: function _loadIframeAPI(cb) {\n      // If API is loaded, there is nothing else to do\n      if (window.YT && typeof window.YT.Player === 'function') {\n        return cb(null, window.YT);\n      } // Otherwise, queue callback until API is loaded\n\n\n      loadIframeAPICallbacks.push(cb);\n      var scripts = Array.from(document.getElementsByTagName('script'));\n      var isLoading = scripts.some(function (script) {\n        return script.src === YOUTUBE_IFRAME_API_SRC;\n      }); // If API <script> tag is not present in the page, inject it. Ensures that\n      // if user includes a hardcoded <script> tag in HTML for performance, another\n      // one will not be added\n\n      if (!isLoading) {\n        loadScript(YOUTUBE_IFRAME_API_SRC).catch(function (err) {\n          while (loadIframeAPICallbacks.length) {\n            var loadCb = loadIframeAPICallbacks.shift();\n            loadCb(err);\n          }\n        });\n      } // If ready function is not present, create it\n\n\n      if (typeof window.onYouTubeIframeAPIReady !== 'function') {\n        window.onYouTubeIframeAPIReady = function () {\n          while (loadIframeAPICallbacks.length) {\n            var loadCb = loadIframeAPICallbacks.shift();\n            loadCb(null, window.YT);\n          }\n        };\n      }\n    }\n  }, {\n    key: \"_createPlayer\",\n    value: function _createPlayer(videoId) {\n      var _this2 = this;\n\n      if (this.destroyed) return;\n      var opts = this._opts;\n      this._player = new this._api.Player(this._id, {\n        width: opts.width,\n        height: opts.height,\n        videoId: videoId,\n        playerVars: {\n          // This parameter specifies whether the initial video will automatically\n          // start to play when the player loads. Supported values are 0 or 1. The\n          // default value is 0.\n          autoplay: opts.autoplay ? 1 : 0,\n          // Setting the parameter's value to 1 causes closed captions to be shown\n          // by default, even if the user has turned captions off. The default\n          // behavior is based on user preference.\n          cc_load_policy: opts.captions != null ? opts.captions ? 1 : 0 : undefined,\n          // default to not setting this option\n          // This parameter indicates whether the video player controls are\n          // displayed. For IFrame embeds that load a Flash player, it also defines\n          // when the controls display in the player as well as when the player\n          // will load. Supported values are:\n          //   - controls=0 – Player controls do not display in the player. For\n          //                  IFrame embeds, the Flash player loads immediately.\n          //   - controls=1 – (default) Player controls display in the player. For\n          //                  IFrame embeds, the controls display immediately and\n          //                  the Flash player also loads immediately.\n          //   - controls=2 – Player controls display in the player. For IFrame\n          //                  embeds, the controls display and the Flash player\n          //                  loads after the user initiates the video playback.\n          controls: opts.controls ? 2 : 0,\n          // Setting the parameter's value to 1 causes the player to not respond to\n          // keyboard controls. The default value is 0, which means that keyboard\n          // controls are enabled.\n          disablekb: opts.keyboard ? 0 : 1,\n          // Setting the parameter's value to 1 enables the player to be\n          // controlled via IFrame or JavaScript Player API calls. The default\n          // value is 0, which means that the player cannot be controlled using\n          // those APIs.\n          enablejsapi: 1,\n          // Setting this parameter to 0 prevents the fullscreen button from\n          // displaying in the player. The default value is 1, which causes the\n          // fullscreen button to display.\n          fs: opts.fullscreen ? 1 : 0,\n          // Setting the parameter's value to 1 causes video annotations to be\n          // shown by default, whereas setting to 3 causes video annotations to not\n          // be shown by default. The default value is 1.\n          iv_load_policy: opts.annotations ? 1 : 3,\n          // This parameter lets you use a YouTube player that does not show a\n          // YouTube logo. Set the parameter value to 1 to prevent the YouTube logo\n          // from displaying in the control bar. Note that a small YouTube text\n          // label will still display in the upper-right corner of a paused video\n          // when the user's mouse pointer hovers over the player.\n          modestbranding: opts.modestBranding ? 1 : 0,\n          // This parameter provides an extra security measure for the IFrame API\n          // and is only supported for IFrame embeds. If you are using the IFrame\n          // API, which means you are setting the enablejsapi parameter value to 1,\n          // you should always specify your domain as the origin parameter value.\n          origin: window.location.origin,\n          // This parameter controls whether videos play inline or fullscreen in an\n          // HTML5 player on iOS. Valid values are:\n          //   - 0: This value causes fullscreen playback. This is currently the\n          //        default value, though the default is subject to change.\n          //   - 1: This value causes inline playback for UIWebViews created with\n          //        the allowsInlineMediaPlayback property set to TRUE.\n          playsinline: 1,\n          // This parameter indicates whether the player should show related videos\n          // when playback of the initial video ends. Supported values are 0 and 1.\n          // The default value is 1.\n          rel: opts.related ? 1 : 0,\n          // Supported values are 0 and 1. Setting the parameter's value to 0\n          // causes the player to not display information like the video title and\n          // uploader before the video starts playing. If the player is loading a\n          // playlist, and you explicitly set the parameter value to 1, then, upon\n          // loading, the player will also display thumbnail images for the videos\n          // in the playlist. Note that this functionality is only supported for\n          // the AS3 player.\n          showinfo: opts.info ? 1 : 0,\n          // (Not part of documented API) Allow html elements with higher z-index\n          // to be shown on top of the YouTube player.\n          wmode: 'opaque'\n        },\n        events: {\n          onReady: function onReady() {\n            return _this2._onReady(videoId);\n          },\n          onStateChange: function onStateChange(data) {\n            return _this2._onStateChange(data);\n          },\n          onPlaybackQualityChange: function onPlaybackQualityChange(data) {\n            return _this2._onPlaybackQualityChange(data);\n          },\n          onPlaybackRateChange: function onPlaybackRateChange(data) {\n            return _this2._onPlaybackRateChange(data);\n          },\n          onError: function onError(data) {\n            return _this2._onError(data);\n          }\n        }\n      });\n    }\n    /**\n     * This event fires when the player has finished loading and is ready to begin\n     * receiving API calls.\n     */\n\n  }, {\n    key: \"_onReady\",\n    value: function _onReady(videoId) {\n      if (this.destroyed) return;\n      this._ready = true; // Once the player is ready, always call `load(videoId, [autoplay])` to handle\n      // these possible cases:\n      //\n      //   1. `load(videoId, true)` was called before the player was ready. Ensure that\n      //      the selected video starts to play.\n      //\n      //   2. `load(videoId, false)` was called before the player was ready. Now the\n      //      player is ready and there's nothing to do.\n      //\n      //   3. `load(videoId, [autoplay])` was called multiple times before the player\n      //      was ready. Therefore, the player was initialized with the wrong videoId,\n      //      so load the latest videoId and potentially autoplay it.\n\n      this.load(this.videoId, this._autoplay);\n\n      this._flushQueue();\n    }\n    /**\n     * Called when the player's state changes. We emit friendly events so the user\n     * doesn't need to use YouTube's YT.PlayerState.* event constants.\n     */\n\n  }, {\n    key: \"_onStateChange\",\n    value: function _onStateChange(data) {\n      if (this.destroyed) return;\n      var state = YOUTUBE_STATES[data.data];\n\n      if (state) {\n        // Send a 'timeupdate' anytime the state changes. When the video halts for any\n        // reason ('paused', 'buffering', or 'ended') no further 'timeupdate' events\n        // should fire until the video unhalts.\n        if (['paused', 'buffering', 'ended'].includes(state)) this._onTimeupdate();\n        this.emit(state); // When the video changes ('unstarted' or 'cued') or starts ('playing') then a\n        // 'timeupdate' should follow afterwards (never before!) to reset the time.\n\n        if (['unstarted', 'playing', 'cued'].includes(state)) this._onTimeupdate();\n      } else {\n        throw new Error('Unrecognized state change: ' + data);\n      }\n    }\n    /**\n     * This event fires whenever the video playback quality changes. Possible\n     * values are: 'small', 'medium', 'large', 'hd720', 'hd1080', 'highres'.\n     */\n\n  }, {\n    key: \"_onPlaybackQualityChange\",\n    value: function _onPlaybackQualityChange(data) {\n      if (this.destroyed) return;\n      this.emit('playbackQualityChange', data.data);\n    }\n    /**\n     * This event fires whenever the video playback rate changes.\n     */\n\n  }, {\n    key: \"_onPlaybackRateChange\",\n    value: function _onPlaybackRateChange(data) {\n      if (this.destroyed) return;\n      this.emit('playbackRateChange', data.data);\n    }\n    /**\n     * This event fires if an error occurs in the player.\n     */\n\n  }, {\n    key: \"_onError\",\n    value: function _onError(data) {\n      if (this.destroyed) return;\n      var code = data.data; // The HTML5_ERROR error occurs when the YouTube player needs to switch from\n      // HTML5 to Flash to show an ad. Ignore it.\n\n      if (code === YOUTUBE_ERROR.HTML5_ERROR) return; // The remaining error types occur when the YouTube player cannot play the\n      // given video. This is not a fatal error. Report it as unplayable so the user\n      // has an opportunity to play another video.\n\n      if (code === YOUTUBE_ERROR.UNPLAYABLE_1 || code === YOUTUBE_ERROR.UNPLAYABLE_2 || code === YOUTUBE_ERROR.NOT_FOUND || code === YOUTUBE_ERROR.INVALID_PARAM) {\n        return this.emit('unplayable', this.videoId);\n      } // Unexpected error, does not match any known type\n\n\n      this._destroy(new Error('YouTube Player Error. Unknown error code: ' + code));\n    }\n    /**\n     * This event fires when the time indicated by the `getCurrentTime()` method\n     * has been updated.\n     */\n\n  }, {\n    key: \"_onTimeupdate\",\n    value: function _onTimeupdate() {\n      this.emit('timeupdate', this.getCurrentTime());\n    }\n  }, {\n    key: \"_startInterval\",\n    value: function _startInterval() {\n      var _this3 = this;\n\n      this._interval = setInterval(function () {\n        return _this3._onTimeupdate();\n      }, this._opts.timeupdateFrequency);\n    }\n  }, {\n    key: \"_stopInterval\",\n    value: function _stopInterval() {\n      clearInterval(this._interval);\n      this._interval = null;\n    }\n  }]);\n\n  return YouTubePlayer;\n}(EventEmitter);\n\nmodule.exports = YouTubePlayer;","map":null,"metadata":{},"sourceType":"script"}